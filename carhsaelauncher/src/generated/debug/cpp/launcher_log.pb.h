// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: launcher_log.proto

#ifndef PROTOBUF_launcher_5flog_2eproto__INCLUDED
#define PROTOBUF_launcher_5flog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "launcher_log_extension.pb.h"
// @@protoc_insertion_point(includes)

namespace userevent {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_launcher_5flog_2eproto();
void protobuf_InitDefaults_launcher_5flog_2eproto();
void protobuf_AssignDesc_launcher_5flog_2eproto();
void protobuf_ShutdownFile_launcher_5flog_2eproto();

class Action;
class LauncherEvent;
class Target;

enum Target_Type {
  Target_Type_NONE = 0,
  Target_Type_ITEM = 1,
  Target_Type_CONTROL = 2,
  Target_Type_CONTAINER = 3
};
bool Target_Type_IsValid(int value);
const Target_Type Target_Type_Type_MIN = Target_Type_NONE;
const Target_Type Target_Type_Type_MAX = Target_Type_CONTAINER;
const int Target_Type_Type_ARRAYSIZE = Target_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Target_Type_descriptor();
inline const ::std::string& Target_Type_Name(Target_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Target_Type_descriptor(), value);
}
inline bool Target_Type_Parse(
    const ::std::string& name, Target_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Target_Type>(
    Target_Type_descriptor(), name, value);
}
enum Action_Type {
  Action_Type_TOUCH = 0,
  Action_Type_AUTOMATED = 1,
  Action_Type_COMMAND = 2,
  Action_Type_TIP = 3
};
bool Action_Type_IsValid(int value);
const Action_Type Action_Type_Type_MIN = Action_Type_TOUCH;
const Action_Type Action_Type_Type_MAX = Action_Type_TIP;
const int Action_Type_Type_ARRAYSIZE = Action_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_Type_descriptor();
inline const ::std::string& Action_Type_Name(Action_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_Type_descriptor(), value);
}
inline bool Action_Type_Parse(
    const ::std::string& name, Action_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_Type>(
    Action_Type_descriptor(), name, value);
}
enum Action_Touch {
  Action_Touch_TAP = 0,
  Action_Touch_LONGPRESS = 1,
  Action_Touch_DRAGDROP = 2,
  Action_Touch_SWIPE = 3,
  Action_Touch_FLING = 4,
  Action_Touch_PINCH = 5
};
bool Action_Touch_IsValid(int value);
const Action_Touch Action_Touch_Touch_MIN = Action_Touch_TAP;
const Action_Touch Action_Touch_Touch_MAX = Action_Touch_PINCH;
const int Action_Touch_Touch_ARRAYSIZE = Action_Touch_Touch_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_Touch_descriptor();
inline const ::std::string& Action_Touch_Name(Action_Touch value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_Touch_descriptor(), value);
}
inline bool Action_Touch_Parse(
    const ::std::string& name, Action_Touch* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_Touch>(
    Action_Touch_descriptor(), name, value);
}
enum Action_Direction {
  Action_Direction_NONE = 0,
  Action_Direction_UP = 1,
  Action_Direction_DOWN = 2,
  Action_Direction_LEFT = 3,
  Action_Direction_RIGHT = 4
};
bool Action_Direction_IsValid(int value);
const Action_Direction Action_Direction_Direction_MIN = Action_Direction_NONE;
const Action_Direction Action_Direction_Direction_MAX = Action_Direction_RIGHT;
const int Action_Direction_Direction_ARRAYSIZE = Action_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_Direction_descriptor();
inline const ::std::string& Action_Direction_Name(Action_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_Direction_descriptor(), value);
}
inline bool Action_Direction_Parse(
    const ::std::string& name, Action_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_Direction>(
    Action_Direction_descriptor(), name, value);
}
enum Action_Command {
  Action_Command_HOME_INTENT = 0,
  Action_Command_BACK = 1,
  Action_Command_ENTRY = 2,
  Action_Command_CANCEL = 3,
  Action_Command_CONFIRM = 4,
  Action_Command_STOP = 5,
  Action_Command_RECENTS_BUTTON = 6,
  Action_Command_RESUME = 7
};
bool Action_Command_IsValid(int value);
const Action_Command Action_Command_Command_MIN = Action_Command_HOME_INTENT;
const Action_Command Action_Command_Command_MAX = Action_Command_RESUME;
const int Action_Command_Command_ARRAYSIZE = Action_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_Command_descriptor();
inline const ::std::string& Action_Command_Name(Action_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_Command_descriptor(), value);
}
inline bool Action_Command_Parse(
    const ::std::string& name, Action_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_Command>(
    Action_Command_descriptor(), name, value);
}
enum ItemType {
  DEFAULT_ITEMTYPE = 0,
  APP_ICON = 1,
  SHORTCUT = 2,
  WIDGET = 3,
  FOLDER_ICON = 4,
  DEEPSHORTCUT = 5,
  SEARCHBOX = 6,
  EDITTEXT = 7,
  NOTIFICATION = 8,
  TASK = 9,
  WEB_APP = 10
};
bool ItemType_IsValid(int value);
const ItemType ItemType_MIN = DEFAULT_ITEMTYPE;
const ItemType ItemType_MAX = WEB_APP;
const int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemType_descriptor();
inline const ::std::string& ItemType_Name(ItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemType_descriptor(), value);
}
inline bool ItemType_Parse(
    const ::std::string& name, ItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum ContainerType {
  DEFAULT_CONTAINERTYPE = 0,
  WORKSPACE = 1,
  HOTSEAT = 2,
  FOLDER = 3,
  ALLAPPS = 4,
  WIDGETS = 5,
  OVERVIEW = 6,
  PREDICTION = 7,
  SEARCHRESULT = 8,
  DEEPSHORTCUTS = 9,
  PINITEM = 10,
  NAVBAR = 11,
  TASKSWITCHER = 12,
  APP = 13,
  TIP = 14,
  SIDELOADED_LAUNCHER = 15
};
bool ContainerType_IsValid(int value);
const ContainerType ContainerType_MIN = DEFAULT_CONTAINERTYPE;
const ContainerType ContainerType_MAX = SIDELOADED_LAUNCHER;
const int ContainerType_ARRAYSIZE = ContainerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerType_descriptor();
inline const ::std::string& ContainerType_Name(ContainerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerType_descriptor(), value);
}
inline bool ContainerType_Parse(
    const ::std::string& name, ContainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerType>(
    ContainerType_descriptor(), name, value);
}
enum ControlType {
  DEFAULT_CONTROLTYPE = 0,
  ALL_APPS_BUTTON = 1,
  WIDGETS_BUTTON = 2,
  WALLPAPER_BUTTON = 3,
  SETTINGS_BUTTON = 4,
  REMOVE_TARGET = 5,
  UNINSTALL_TARGET = 6,
  APPINFO_TARGET = 7,
  RESIZE_HANDLE = 8,
  VERTICAL_SCROLL = 9,
  HOME_INTENT = 10,
  BACK_BUTTON = 11,
  QUICK_SCRUB_BUTTON = 12,
  CLEAR_ALL_BUTTON = 13,
  CANCEL_TARGET = 14,
  TASK_PREVIEW = 15,
  SPLIT_SCREEN_TARGET = 16
};
bool ControlType_IsValid(int value);
const ControlType ControlType_MIN = DEFAULT_CONTROLTYPE;
const ControlType ControlType_MAX = SPLIT_SCREEN_TARGET;
const int ControlType_ARRAYSIZE = ControlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlType_descriptor();
inline const ::std::string& ControlType_Name(ControlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlType_descriptor(), value);
}
inline bool ControlType_Parse(
    const ::std::string& name, ControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlType>(
    ControlType_descriptor(), name, value);
}
enum TipType {
  DEFAULT_NONE = 0,
  BOUNCE = 1,
  SWIPE_UP_TEXT = 2,
  QUICK_SCRUB_TEXT = 3,
  PREDICTION_TEXT = 4
};
bool TipType_IsValid(int value);
const TipType TipType_MIN = DEFAULT_NONE;
const TipType TipType_MAX = PREDICTION_TEXT;
const int TipType_ARRAYSIZE = TipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TipType_descriptor();
inline const ::std::string& TipType_Name(TipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TipType_descriptor(), value);
}
inline bool TipType_Parse(
    const ::std::string& name, TipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TipType>(
    TipType_descriptor(), name, value);
}
// ===================================================================

class Target : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userevent.Target) */ {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  static const Target* internal_default_instance();

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  inline Target* New() const { return New(NULL); }

  Target* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Target* other);
  void UnsafeMergeFrom(const Target& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Target_Type Type;
  static const Type NONE =
    Target_Type_NONE;
  static const Type ITEM =
    Target_Type_ITEM;
  static const Type CONTROL =
    Target_Type_CONTROL;
  static const Type CONTAINER =
    Target_Type_CONTAINER;
  static inline bool Type_IsValid(int value) {
    return Target_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Target_Type_Type_MIN;
  static const Type Type_MAX =
    Target_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Target_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Target_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Target_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Target_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .userevent.Target.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::userevent::Target_Type type() const;
  void set_type(::userevent::Target_Type value);

  // optional int32 page_index = 2;
  bool has_page_index() const;
  void clear_page_index();
  static const int kPageIndexFieldNumber = 2;
  ::google::protobuf::int32 page_index() const;
  void set_page_index(::google::protobuf::int32 value);

  // optional int32 rank = 3;
  bool has_rank() const;
  void clear_rank();
  static const int kRankFieldNumber = 3;
  ::google::protobuf::int32 rank() const;
  void set_rank(::google::protobuf::int32 value);

  // optional int32 grid_x = 4;
  bool has_grid_x() const;
  void clear_grid_x();
  static const int kGridXFieldNumber = 4;
  ::google::protobuf::int32 grid_x() const;
  void set_grid_x(::google::protobuf::int32 value);

  // optional int32 grid_y = 5;
  bool has_grid_y() const;
  void clear_grid_y();
  static const int kGridYFieldNumber = 5;
  ::google::protobuf::int32 grid_y() const;
  void set_grid_y(::google::protobuf::int32 value);

  // optional .userevent.ContainerType container_type = 6;
  bool has_container_type() const;
  void clear_container_type();
  static const int kContainerTypeFieldNumber = 6;
  ::userevent::ContainerType container_type() const;
  void set_container_type(::userevent::ContainerType value);

  // optional int32 cardinality = 7;
  bool has_cardinality() const;
  void clear_cardinality();
  static const int kCardinalityFieldNumber = 7;
  ::google::protobuf::int32 cardinality() const;
  void set_cardinality(::google::protobuf::int32 value);

  // optional .userevent.ControlType control_type = 8;
  bool has_control_type() const;
  void clear_control_type();
  static const int kControlTypeFieldNumber = 8;
  ::userevent::ControlType control_type() const;
  void set_control_type(::userevent::ControlType value);

  // optional .userevent.ItemType item_type = 9;
  bool has_item_type() const;
  void clear_item_type();
  static const int kItemTypeFieldNumber = 9;
  ::userevent::ItemType item_type() const;
  void set_item_type(::userevent::ItemType value);

  // optional int32 package_name_hash = 10;
  bool has_package_name_hash() const;
  void clear_package_name_hash();
  static const int kPackageNameHashFieldNumber = 10;
  ::google::protobuf::int32 package_name_hash() const;
  void set_package_name_hash(::google::protobuf::int32 value);

  // optional int32 component_hash = 11;
  bool has_component_hash() const;
  void clear_component_hash();
  static const int kComponentHashFieldNumber = 11;
  ::google::protobuf::int32 component_hash() const;
  void set_component_hash(::google::protobuf::int32 value);

  // optional int32 intent_hash = 12;
  bool has_intent_hash() const;
  void clear_intent_hash();
  static const int kIntentHashFieldNumber = 12;
  ::google::protobuf::int32 intent_hash() const;
  void set_intent_hash(::google::protobuf::int32 value);

  // optional int32 span_x = 13 [default = 1];
  bool has_span_x() const;
  void clear_span_x();
  static const int kSpanXFieldNumber = 13;
  ::google::protobuf::int32 span_x() const;
  void set_span_x(::google::protobuf::int32 value);

  // optional int32 span_y = 14 [default = 1];
  bool has_span_y() const;
  void clear_span_y();
  static const int kSpanYFieldNumber = 14;
  ::google::protobuf::int32 span_y() const;
  void set_span_y(::google::protobuf::int32 value);

  // optional int32 predictedRank = 15;
  bool has_predictedrank() const;
  void clear_predictedrank();
  static const int kPredictedRankFieldNumber = 15;
  ::google::protobuf::int32 predictedrank() const;
  void set_predictedrank(::google::protobuf::int32 value);

  // optional .userevent.TargetExtension extension = 16;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 16;
  const ::userevent::TargetExtension& extension() const;
  ::userevent::TargetExtension* mutable_extension();
  ::userevent::TargetExtension* release_extension();
  void set_allocated_extension(::userevent::TargetExtension* extension);

  // optional .userevent.TipType tip_type = 17;
  bool has_tip_type() const;
  void clear_tip_type();
  static const int kTipTypeFieldNumber = 17;
  ::userevent::TipType tip_type() const;
  void set_tip_type(::userevent::TipType value);

  // @@protoc_insertion_point(class_scope:userevent.Target)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_page_index();
  inline void clear_has_page_index();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_grid_x();
  inline void clear_has_grid_x();
  inline void set_has_grid_y();
  inline void clear_has_grid_y();
  inline void set_has_container_type();
  inline void clear_has_container_type();
  inline void set_has_cardinality();
  inline void clear_has_cardinality();
  inline void set_has_control_type();
  inline void clear_has_control_type();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_package_name_hash();
  inline void clear_has_package_name_hash();
  inline void set_has_component_hash();
  inline void clear_has_component_hash();
  inline void set_has_intent_hash();
  inline void clear_has_intent_hash();
  inline void set_has_span_x();
  inline void clear_has_span_x();
  inline void set_has_span_y();
  inline void clear_has_span_y();
  inline void set_has_predictedrank();
  inline void clear_has_predictedrank();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_tip_type();
  inline void clear_has_tip_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::userevent::TargetExtension* extension_;
  int type_;
  ::google::protobuf::int32 page_index_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 grid_x_;
  ::google::protobuf::int32 grid_y_;
  int container_type_;
  ::google::protobuf::int32 cardinality_;
  int control_type_;
  int item_type_;
  ::google::protobuf::int32 package_name_hash_;
  ::google::protobuf::int32 component_hash_;
  ::google::protobuf::int32 intent_hash_;
  ::google::protobuf::int32 predictedrank_;
  int tip_type_;
  ::google::protobuf::int32 span_x_;
  ::google::protobuf::int32 span_y_;
  friend void  protobuf_InitDefaults_launcher_5flog_2eproto_impl();
  friend void  protobuf_AddDesc_launcher_5flog_2eproto_impl();
  friend void protobuf_AssignDesc_launcher_5flog_2eproto();
  friend void protobuf_ShutdownFile_launcher_5flog_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Target> Target_default_instance_;

// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userevent.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static const Action* internal_default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  inline Action* New() const { return New(NULL); }

  Action* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Action* other);
  void UnsafeMergeFrom(const Action& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Action_Type Type;
  static const Type TOUCH =
    Action_Type_TOUCH;
  static const Type AUTOMATED =
    Action_Type_AUTOMATED;
  static const Type COMMAND =
    Action_Type_COMMAND;
  static const Type TIP =
    Action_Type_TIP;
  static inline bool Type_IsValid(int value) {
    return Action_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Action_Type_Type_MIN;
  static const Type Type_MAX =
    Action_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Action_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Action_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Action_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Action_Type_Parse(name, value);
  }

  typedef Action_Touch Touch;
  static const Touch TAP =
    Action_Touch_TAP;
  static const Touch LONGPRESS =
    Action_Touch_LONGPRESS;
  static const Touch DRAGDROP =
    Action_Touch_DRAGDROP;
  static const Touch SWIPE =
    Action_Touch_SWIPE;
  static const Touch FLING =
    Action_Touch_FLING;
  static const Touch PINCH =
    Action_Touch_PINCH;
  static inline bool Touch_IsValid(int value) {
    return Action_Touch_IsValid(value);
  }
  static const Touch Touch_MIN =
    Action_Touch_Touch_MIN;
  static const Touch Touch_MAX =
    Action_Touch_Touch_MAX;
  static const int Touch_ARRAYSIZE =
    Action_Touch_Touch_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Touch_descriptor() {
    return Action_Touch_descriptor();
  }
  static inline const ::std::string& Touch_Name(Touch value) {
    return Action_Touch_Name(value);
  }
  static inline bool Touch_Parse(const ::std::string& name,
      Touch* value) {
    return Action_Touch_Parse(name, value);
  }

  typedef Action_Direction Direction;
  static const Direction NONE =
    Action_Direction_NONE;
  static const Direction UP =
    Action_Direction_UP;
  static const Direction DOWN =
    Action_Direction_DOWN;
  static const Direction LEFT =
    Action_Direction_LEFT;
  static const Direction RIGHT =
    Action_Direction_RIGHT;
  static inline bool Direction_IsValid(int value) {
    return Action_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Action_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Action_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Action_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Action_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Action_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Action_Direction_Parse(name, value);
  }

  typedef Action_Command Command;
  static const Command HOME_INTENT =
    Action_Command_HOME_INTENT;
  static const Command BACK =
    Action_Command_BACK;
  static const Command ENTRY =
    Action_Command_ENTRY;
  static const Command CANCEL =
    Action_Command_CANCEL;
  static const Command CONFIRM =
    Action_Command_CONFIRM;
  static const Command STOP =
    Action_Command_STOP;
  static const Command RECENTS_BUTTON =
    Action_Command_RECENTS_BUTTON;
  static const Command RESUME =
    Action_Command_RESUME;
  static inline bool Command_IsValid(int value) {
    return Action_Command_IsValid(value);
  }
  static const Command Command_MIN =
    Action_Command_Command_MIN;
  static const Command Command_MAX =
    Action_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    Action_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return Action_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return Action_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return Action_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .userevent.Action.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::userevent::Action_Type type() const;
  void set_type(::userevent::Action_Type value);

  // optional .userevent.Action.Touch touch = 2;
  bool has_touch() const;
  void clear_touch();
  static const int kTouchFieldNumber = 2;
  ::userevent::Action_Touch touch() const;
  void set_touch(::userevent::Action_Touch value);

  // optional .userevent.Action.Direction dir = 3;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 3;
  ::userevent::Action_Direction dir() const;
  void set_dir(::userevent::Action_Direction value);

  // optional .userevent.Action.Command command = 4;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 4;
  ::userevent::Action_Command command() const;
  void set_command(::userevent::Action_Command value);

  // optional bool is_outside = 5;
  bool has_is_outside() const;
  void clear_is_outside();
  static const int kIsOutsideFieldNumber = 5;
  bool is_outside() const;
  void set_is_outside(bool value);

  // optional bool is_state_change = 6;
  bool has_is_state_change() const;
  void clear_is_state_change();
  static const int kIsStateChangeFieldNumber = 6;
  bool is_state_change() const;
  void set_is_state_change(bool value);

  // @@protoc_insertion_point(class_scope:userevent.Action)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_touch();
  inline void clear_has_touch();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_is_outside();
  inline void clear_has_is_outside();
  inline void set_has_is_state_change();
  inline void clear_has_is_state_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  int touch_;
  int dir_;
  int command_;
  bool is_outside_;
  bool is_state_change_;
  friend void  protobuf_InitDefaults_launcher_5flog_2eproto_impl();
  friend void  protobuf_AddDesc_launcher_5flog_2eproto_impl();
  friend void protobuf_AssignDesc_launcher_5flog_2eproto();
  friend void protobuf_ShutdownFile_launcher_5flog_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Action> Action_default_instance_;

// -------------------------------------------------------------------

class LauncherEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userevent.LauncherEvent) */ {
 public:
  LauncherEvent();
  virtual ~LauncherEvent();

  LauncherEvent(const LauncherEvent& from);

  inline LauncherEvent& operator=(const LauncherEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LauncherEvent& default_instance();

  static const LauncherEvent* internal_default_instance();

  void Swap(LauncherEvent* other);

  // implements Message ----------------------------------------------

  inline LauncherEvent* New() const { return New(NULL); }

  LauncherEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LauncherEvent& from);
  void MergeFrom(const LauncherEvent& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LauncherEvent* other);
  void UnsafeMergeFrom(const LauncherEvent& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .userevent.Action action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::userevent::Action& action() const;
  ::userevent::Action* mutable_action();
  ::userevent::Action* release_action();
  void set_allocated_action(::userevent::Action* action);

  // repeated .userevent.Target src_target = 2;
  int src_target_size() const;
  void clear_src_target();
  static const int kSrcTargetFieldNumber = 2;
  const ::userevent::Target& src_target(int index) const;
  ::userevent::Target* mutable_src_target(int index);
  ::userevent::Target* add_src_target();
  ::google::protobuf::RepeatedPtrField< ::userevent::Target >*
      mutable_src_target();
  const ::google::protobuf::RepeatedPtrField< ::userevent::Target >&
      src_target() const;

  // repeated .userevent.Target dest_target = 3;
  int dest_target_size() const;
  void clear_dest_target();
  static const int kDestTargetFieldNumber = 3;
  const ::userevent::Target& dest_target(int index) const;
  ::userevent::Target* mutable_dest_target(int index);
  ::userevent::Target* add_dest_target();
  ::google::protobuf::RepeatedPtrField< ::userevent::Target >*
      mutable_dest_target();
  const ::google::protobuf::RepeatedPtrField< ::userevent::Target >&
      dest_target() const;

  // optional int64 action_duration_millis = 4;
  bool has_action_duration_millis() const;
  void clear_action_duration_millis();
  static const int kActionDurationMillisFieldNumber = 4;
  ::google::protobuf::int64 action_duration_millis() const;
  void set_action_duration_millis(::google::protobuf::int64 value);

  // optional int64 elapsed_container_millis = 5;
  bool has_elapsed_container_millis() const;
  void clear_elapsed_container_millis();
  static const int kElapsedContainerMillisFieldNumber = 5;
  ::google::protobuf::int64 elapsed_container_millis() const;
  void set_elapsed_container_millis(::google::protobuf::int64 value);

  // optional int64 elapsed_session_millis = 6;
  bool has_elapsed_session_millis() const;
  void clear_elapsed_session_millis();
  static const int kElapsedSessionMillisFieldNumber = 6;
  ::google::protobuf::int64 elapsed_session_millis() const;
  void set_elapsed_session_millis(::google::protobuf::int64 value);

  // optional bool is_in_multi_window_mode = 7;
  bool has_is_in_multi_window_mode() const;
  void clear_is_in_multi_window_mode();
  static const int kIsInMultiWindowModeFieldNumber = 7;
  bool is_in_multi_window_mode() const;
  void set_is_in_multi_window_mode(bool value);

  // optional bool is_in_landscape_mode = 8;
  bool has_is_in_landscape_mode() const;
  void clear_is_in_landscape_mode();
  static const int kIsInLandscapeModeFieldNumber = 8;
  bool is_in_landscape_mode() const;
  void set_is_in_landscape_mode(bool value);

  // optional .userevent.LauncherEventExtension extension = 9;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 9;
  const ::userevent::LauncherEventExtension& extension() const;
  ::userevent::LauncherEventExtension* mutable_extension();
  ::userevent::LauncherEventExtension* release_extension();
  void set_allocated_extension(::userevent::LauncherEventExtension* extension);

  // @@protoc_insertion_point(class_scope:userevent.LauncherEvent)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_action_duration_millis();
  inline void clear_has_action_duration_millis();
  inline void set_has_elapsed_container_millis();
  inline void clear_has_elapsed_container_millis();
  inline void set_has_elapsed_session_millis();
  inline void clear_has_elapsed_session_millis();
  inline void set_has_is_in_multi_window_mode();
  inline void clear_has_is_in_multi_window_mode();
  inline void set_has_is_in_landscape_mode();
  inline void clear_has_is_in_landscape_mode();
  inline void set_has_extension();
  inline void clear_has_extension();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::userevent::Target > src_target_;
  ::google::protobuf::RepeatedPtrField< ::userevent::Target > dest_target_;
  ::userevent::Action* action_;
  ::userevent::LauncherEventExtension* extension_;
  ::google::protobuf::int64 action_duration_millis_;
  ::google::protobuf::int64 elapsed_container_millis_;
  ::google::protobuf::int64 elapsed_session_millis_;
  bool is_in_multi_window_mode_;
  bool is_in_landscape_mode_;
  friend void  protobuf_InitDefaults_launcher_5flog_2eproto_impl();
  friend void  protobuf_AddDesc_launcher_5flog_2eproto_impl();
  friend void protobuf_AssignDesc_launcher_5flog_2eproto();
  friend void protobuf_ShutdownFile_launcher_5flog_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LauncherEvent> LauncherEvent_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Target

// optional .userevent.Target.Type type = 1;
inline bool Target::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::userevent::Target_Type Target::type() const {
  // @@protoc_insertion_point(field_get:userevent.Target.type)
  return static_cast< ::userevent::Target_Type >(type_);
}
inline void Target::set_type(::userevent::Target_Type value) {
  assert(::userevent::Target_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.type)
}

// optional int32 page_index = 2;
inline bool Target::has_page_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::set_has_page_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Target::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Target::clear_page_index() {
  page_index_ = 0;
  clear_has_page_index();
}
inline ::google::protobuf::int32 Target::page_index() const {
  // @@protoc_insertion_point(field_get:userevent.Target.page_index)
  return page_index_;
}
inline void Target::set_page_index(::google::protobuf::int32 value) {
  set_has_page_index();
  page_index_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.page_index)
}

// optional int32 rank = 3;
inline bool Target::has_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Target::set_has_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Target::clear_has_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Target::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 Target::rank() const {
  // @@protoc_insertion_point(field_get:userevent.Target.rank)
  return rank_;
}
inline void Target::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.rank)
}

// optional int32 grid_x = 4;
inline bool Target::has_grid_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Target::set_has_grid_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Target::clear_has_grid_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Target::clear_grid_x() {
  grid_x_ = 0;
  clear_has_grid_x();
}
inline ::google::protobuf::int32 Target::grid_x() const {
  // @@protoc_insertion_point(field_get:userevent.Target.grid_x)
  return grid_x_;
}
inline void Target::set_grid_x(::google::protobuf::int32 value) {
  set_has_grid_x();
  grid_x_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.grid_x)
}

// optional int32 grid_y = 5;
inline bool Target::has_grid_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Target::set_has_grid_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Target::clear_has_grid_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Target::clear_grid_y() {
  grid_y_ = 0;
  clear_has_grid_y();
}
inline ::google::protobuf::int32 Target::grid_y() const {
  // @@protoc_insertion_point(field_get:userevent.Target.grid_y)
  return grid_y_;
}
inline void Target::set_grid_y(::google::protobuf::int32 value) {
  set_has_grid_y();
  grid_y_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.grid_y)
}

// optional .userevent.ContainerType container_type = 6;
inline bool Target::has_container_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Target::set_has_container_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Target::clear_has_container_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Target::clear_container_type() {
  container_type_ = 0;
  clear_has_container_type();
}
inline ::userevent::ContainerType Target::container_type() const {
  // @@protoc_insertion_point(field_get:userevent.Target.container_type)
  return static_cast< ::userevent::ContainerType >(container_type_);
}
inline void Target::set_container_type(::userevent::ContainerType value) {
  assert(::userevent::ContainerType_IsValid(value));
  set_has_container_type();
  container_type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.container_type)
}

// optional int32 cardinality = 7;
inline bool Target::has_cardinality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Target::set_has_cardinality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Target::clear_has_cardinality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Target::clear_cardinality() {
  cardinality_ = 0;
  clear_has_cardinality();
}
inline ::google::protobuf::int32 Target::cardinality() const {
  // @@protoc_insertion_point(field_get:userevent.Target.cardinality)
  return cardinality_;
}
inline void Target::set_cardinality(::google::protobuf::int32 value) {
  set_has_cardinality();
  cardinality_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.cardinality)
}

// optional .userevent.ControlType control_type = 8;
inline bool Target::has_control_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Target::set_has_control_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Target::clear_has_control_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Target::clear_control_type() {
  control_type_ = 0;
  clear_has_control_type();
}
inline ::userevent::ControlType Target::control_type() const {
  // @@protoc_insertion_point(field_get:userevent.Target.control_type)
  return static_cast< ::userevent::ControlType >(control_type_);
}
inline void Target::set_control_type(::userevent::ControlType value) {
  assert(::userevent::ControlType_IsValid(value));
  set_has_control_type();
  control_type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.control_type)
}

// optional .userevent.ItemType item_type = 9;
inline bool Target::has_item_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Target::set_has_item_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Target::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Target::clear_item_type() {
  item_type_ = 0;
  clear_has_item_type();
}
inline ::userevent::ItemType Target::item_type() const {
  // @@protoc_insertion_point(field_get:userevent.Target.item_type)
  return static_cast< ::userevent::ItemType >(item_type_);
}
inline void Target::set_item_type(::userevent::ItemType value) {
  assert(::userevent::ItemType_IsValid(value));
  set_has_item_type();
  item_type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.item_type)
}

// optional int32 package_name_hash = 10;
inline bool Target::has_package_name_hash() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Target::set_has_package_name_hash() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Target::clear_has_package_name_hash() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Target::clear_package_name_hash() {
  package_name_hash_ = 0;
  clear_has_package_name_hash();
}
inline ::google::protobuf::int32 Target::package_name_hash() const {
  // @@protoc_insertion_point(field_get:userevent.Target.package_name_hash)
  return package_name_hash_;
}
inline void Target::set_package_name_hash(::google::protobuf::int32 value) {
  set_has_package_name_hash();
  package_name_hash_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.package_name_hash)
}

// optional int32 component_hash = 11;
inline bool Target::has_component_hash() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Target::set_has_component_hash() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Target::clear_has_component_hash() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Target::clear_component_hash() {
  component_hash_ = 0;
  clear_has_component_hash();
}
inline ::google::protobuf::int32 Target::component_hash() const {
  // @@protoc_insertion_point(field_get:userevent.Target.component_hash)
  return component_hash_;
}
inline void Target::set_component_hash(::google::protobuf::int32 value) {
  set_has_component_hash();
  component_hash_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.component_hash)
}

// optional int32 intent_hash = 12;
inline bool Target::has_intent_hash() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Target::set_has_intent_hash() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Target::clear_has_intent_hash() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Target::clear_intent_hash() {
  intent_hash_ = 0;
  clear_has_intent_hash();
}
inline ::google::protobuf::int32 Target::intent_hash() const {
  // @@protoc_insertion_point(field_get:userevent.Target.intent_hash)
  return intent_hash_;
}
inline void Target::set_intent_hash(::google::protobuf::int32 value) {
  set_has_intent_hash();
  intent_hash_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.intent_hash)
}

// optional int32 span_x = 13 [default = 1];
inline bool Target::has_span_x() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Target::set_has_span_x() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Target::clear_has_span_x() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Target::clear_span_x() {
  span_x_ = 1;
  clear_has_span_x();
}
inline ::google::protobuf::int32 Target::span_x() const {
  // @@protoc_insertion_point(field_get:userevent.Target.span_x)
  return span_x_;
}
inline void Target::set_span_x(::google::protobuf::int32 value) {
  set_has_span_x();
  span_x_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.span_x)
}

// optional int32 span_y = 14 [default = 1];
inline bool Target::has_span_y() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Target::set_has_span_y() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Target::clear_has_span_y() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Target::clear_span_y() {
  span_y_ = 1;
  clear_has_span_y();
}
inline ::google::protobuf::int32 Target::span_y() const {
  // @@protoc_insertion_point(field_get:userevent.Target.span_y)
  return span_y_;
}
inline void Target::set_span_y(::google::protobuf::int32 value) {
  set_has_span_y();
  span_y_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.span_y)
}

// optional int32 predictedRank = 15;
inline bool Target::has_predictedrank() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Target::set_has_predictedrank() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Target::clear_has_predictedrank() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Target::clear_predictedrank() {
  predictedrank_ = 0;
  clear_has_predictedrank();
}
inline ::google::protobuf::int32 Target::predictedrank() const {
  // @@protoc_insertion_point(field_get:userevent.Target.predictedRank)
  return predictedrank_;
}
inline void Target::set_predictedrank(::google::protobuf::int32 value) {
  set_has_predictedrank();
  predictedrank_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.predictedRank)
}

// optional .userevent.TargetExtension extension = 16;
inline bool Target::has_extension() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Target::set_has_extension() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Target::clear_has_extension() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Target::clear_extension() {
  if (extension_ != NULL) extension_->::userevent::TargetExtension::Clear();
  clear_has_extension();
}
inline const ::userevent::TargetExtension& Target::extension() const {
  // @@protoc_insertion_point(field_get:userevent.Target.extension)
  return extension_ != NULL ? *extension_
                         : *::userevent::TargetExtension::internal_default_instance();
}
inline ::userevent::TargetExtension* Target::mutable_extension() {
  set_has_extension();
  if (extension_ == NULL) {
    extension_ = new ::userevent::TargetExtension;
  }
  // @@protoc_insertion_point(field_mutable:userevent.Target.extension)
  return extension_;
}
inline ::userevent::TargetExtension* Target::release_extension() {
  // @@protoc_insertion_point(field_release:userevent.Target.extension)
  clear_has_extension();
  ::userevent::TargetExtension* temp = extension_;
  extension_ = NULL;
  return temp;
}
inline void Target::set_allocated_extension(::userevent::TargetExtension* extension) {
  delete extension_;
  extension_ = extension;
  if (extension) {
    set_has_extension();
  } else {
    clear_has_extension();
  }
  // @@protoc_insertion_point(field_set_allocated:userevent.Target.extension)
}

// optional .userevent.TipType tip_type = 17;
inline bool Target::has_tip_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Target::set_has_tip_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Target::clear_has_tip_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Target::clear_tip_type() {
  tip_type_ = 0;
  clear_has_tip_type();
}
inline ::userevent::TipType Target::tip_type() const {
  // @@protoc_insertion_point(field_get:userevent.Target.tip_type)
  return static_cast< ::userevent::TipType >(tip_type_);
}
inline void Target::set_tip_type(::userevent::TipType value) {
  assert(::userevent::TipType_IsValid(value));
  set_has_tip_type();
  tip_type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Target.tip_type)
}

inline const Target* Target::internal_default_instance() {
  return &Target_default_instance_.get();
}
// -------------------------------------------------------------------

// Action

// optional .userevent.Action.Type type = 1;
inline bool Action::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Action::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::userevent::Action_Type Action::type() const {
  // @@protoc_insertion_point(field_get:userevent.Action.type)
  return static_cast< ::userevent::Action_Type >(type_);
}
inline void Action::set_type(::userevent::Action_Type value) {
  assert(::userevent::Action_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.type)
}

// optional .userevent.Action.Touch touch = 2;
inline bool Action::has_touch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_touch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_touch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Action::clear_touch() {
  touch_ = 0;
  clear_has_touch();
}
inline ::userevent::Action_Touch Action::touch() const {
  // @@protoc_insertion_point(field_get:userevent.Action.touch)
  return static_cast< ::userevent::Action_Touch >(touch_);
}
inline void Action::set_touch(::userevent::Action_Touch value) {
  assert(::userevent::Action_Touch_IsValid(value));
  set_has_touch();
  touch_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.touch)
}

// optional .userevent.Action.Direction dir = 3;
inline bool Action::has_dir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_dir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_dir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Action::clear_dir() {
  dir_ = 0;
  clear_has_dir();
}
inline ::userevent::Action_Direction Action::dir() const {
  // @@protoc_insertion_point(field_get:userevent.Action.dir)
  return static_cast< ::userevent::Action_Direction >(dir_);
}
inline void Action::set_dir(::userevent::Action_Direction value) {
  assert(::userevent::Action_Direction_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.dir)
}

// optional .userevent.Action.Command command = 4;
inline bool Action::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Action::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::userevent::Action_Command Action::command() const {
  // @@protoc_insertion_point(field_get:userevent.Action.command)
  return static_cast< ::userevent::Action_Command >(command_);
}
inline void Action::set_command(::userevent::Action_Command value) {
  assert(::userevent::Action_Command_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.command)
}

// optional bool is_outside = 5;
inline bool Action::has_is_outside() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Action::set_has_is_outside() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Action::clear_has_is_outside() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Action::clear_is_outside() {
  is_outside_ = false;
  clear_has_is_outside();
}
inline bool Action::is_outside() const {
  // @@protoc_insertion_point(field_get:userevent.Action.is_outside)
  return is_outside_;
}
inline void Action::set_is_outside(bool value) {
  set_has_is_outside();
  is_outside_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.is_outside)
}

// optional bool is_state_change = 6;
inline bool Action::has_is_state_change() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Action::set_has_is_state_change() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Action::clear_has_is_state_change() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Action::clear_is_state_change() {
  is_state_change_ = false;
  clear_has_is_state_change();
}
inline bool Action::is_state_change() const {
  // @@protoc_insertion_point(field_get:userevent.Action.is_state_change)
  return is_state_change_;
}
inline void Action::set_is_state_change(bool value) {
  set_has_is_state_change();
  is_state_change_ = value;
  // @@protoc_insertion_point(field_set:userevent.Action.is_state_change)
}

inline const Action* Action::internal_default_instance() {
  return &Action_default_instance_.get();
}
// -------------------------------------------------------------------

// LauncherEvent

// required .userevent.Action action = 1;
inline bool LauncherEvent::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LauncherEvent::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LauncherEvent::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LauncherEvent::clear_action() {
  if (action_ != NULL) action_->::userevent::Action::Clear();
  clear_has_action();
}
inline const ::userevent::Action& LauncherEvent::action() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.action)
  return action_ != NULL ? *action_
                         : *::userevent::Action::internal_default_instance();
}
inline ::userevent::Action* LauncherEvent::mutable_action() {
  set_has_action();
  if (action_ == NULL) {
    action_ = new ::userevent::Action;
  }
  // @@protoc_insertion_point(field_mutable:userevent.LauncherEvent.action)
  return action_;
}
inline ::userevent::Action* LauncherEvent::release_action() {
  // @@protoc_insertion_point(field_release:userevent.LauncherEvent.action)
  clear_has_action();
  ::userevent::Action* temp = action_;
  action_ = NULL;
  return temp;
}
inline void LauncherEvent::set_allocated_action(::userevent::Action* action) {
  delete action_;
  action_ = action;
  if (action) {
    set_has_action();
  } else {
    clear_has_action();
  }
  // @@protoc_insertion_point(field_set_allocated:userevent.LauncherEvent.action)
}

// repeated .userevent.Target src_target = 2;
inline int LauncherEvent::src_target_size() const {
  return src_target_.size();
}
inline void LauncherEvent::clear_src_target() {
  src_target_.Clear();
}
inline const ::userevent::Target& LauncherEvent::src_target(int index) const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.src_target)
  return src_target_.Get(index);
}
inline ::userevent::Target* LauncherEvent::mutable_src_target(int index) {
  // @@protoc_insertion_point(field_mutable:userevent.LauncherEvent.src_target)
  return src_target_.Mutable(index);
}
inline ::userevent::Target* LauncherEvent::add_src_target() {
  // @@protoc_insertion_point(field_add:userevent.LauncherEvent.src_target)
  return src_target_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::userevent::Target >*
LauncherEvent::mutable_src_target() {
  // @@protoc_insertion_point(field_mutable_list:userevent.LauncherEvent.src_target)
  return &src_target_;
}
inline const ::google::protobuf::RepeatedPtrField< ::userevent::Target >&
LauncherEvent::src_target() const {
  // @@protoc_insertion_point(field_list:userevent.LauncherEvent.src_target)
  return src_target_;
}

// repeated .userevent.Target dest_target = 3;
inline int LauncherEvent::dest_target_size() const {
  return dest_target_.size();
}
inline void LauncherEvent::clear_dest_target() {
  dest_target_.Clear();
}
inline const ::userevent::Target& LauncherEvent::dest_target(int index) const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.dest_target)
  return dest_target_.Get(index);
}
inline ::userevent::Target* LauncherEvent::mutable_dest_target(int index) {
  // @@protoc_insertion_point(field_mutable:userevent.LauncherEvent.dest_target)
  return dest_target_.Mutable(index);
}
inline ::userevent::Target* LauncherEvent::add_dest_target() {
  // @@protoc_insertion_point(field_add:userevent.LauncherEvent.dest_target)
  return dest_target_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::userevent::Target >*
LauncherEvent::mutable_dest_target() {
  // @@protoc_insertion_point(field_mutable_list:userevent.LauncherEvent.dest_target)
  return &dest_target_;
}
inline const ::google::protobuf::RepeatedPtrField< ::userevent::Target >&
LauncherEvent::dest_target() const {
  // @@protoc_insertion_point(field_list:userevent.LauncherEvent.dest_target)
  return dest_target_;
}

// optional int64 action_duration_millis = 4;
inline bool LauncherEvent::has_action_duration_millis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LauncherEvent::set_has_action_duration_millis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LauncherEvent::clear_has_action_duration_millis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LauncherEvent::clear_action_duration_millis() {
  action_duration_millis_ = GOOGLE_LONGLONG(0);
  clear_has_action_duration_millis();
}
inline ::google::protobuf::int64 LauncherEvent::action_duration_millis() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.action_duration_millis)
  return action_duration_millis_;
}
inline void LauncherEvent::set_action_duration_millis(::google::protobuf::int64 value) {
  set_has_action_duration_millis();
  action_duration_millis_ = value;
  // @@protoc_insertion_point(field_set:userevent.LauncherEvent.action_duration_millis)
}

// optional int64 elapsed_container_millis = 5;
inline bool LauncherEvent::has_elapsed_container_millis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LauncherEvent::set_has_elapsed_container_millis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LauncherEvent::clear_has_elapsed_container_millis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LauncherEvent::clear_elapsed_container_millis() {
  elapsed_container_millis_ = GOOGLE_LONGLONG(0);
  clear_has_elapsed_container_millis();
}
inline ::google::protobuf::int64 LauncherEvent::elapsed_container_millis() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.elapsed_container_millis)
  return elapsed_container_millis_;
}
inline void LauncherEvent::set_elapsed_container_millis(::google::protobuf::int64 value) {
  set_has_elapsed_container_millis();
  elapsed_container_millis_ = value;
  // @@protoc_insertion_point(field_set:userevent.LauncherEvent.elapsed_container_millis)
}

// optional int64 elapsed_session_millis = 6;
inline bool LauncherEvent::has_elapsed_session_millis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LauncherEvent::set_has_elapsed_session_millis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LauncherEvent::clear_has_elapsed_session_millis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LauncherEvent::clear_elapsed_session_millis() {
  elapsed_session_millis_ = GOOGLE_LONGLONG(0);
  clear_has_elapsed_session_millis();
}
inline ::google::protobuf::int64 LauncherEvent::elapsed_session_millis() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.elapsed_session_millis)
  return elapsed_session_millis_;
}
inline void LauncherEvent::set_elapsed_session_millis(::google::protobuf::int64 value) {
  set_has_elapsed_session_millis();
  elapsed_session_millis_ = value;
  // @@protoc_insertion_point(field_set:userevent.LauncherEvent.elapsed_session_millis)
}

// optional bool is_in_multi_window_mode = 7;
inline bool LauncherEvent::has_is_in_multi_window_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LauncherEvent::set_has_is_in_multi_window_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LauncherEvent::clear_has_is_in_multi_window_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LauncherEvent::clear_is_in_multi_window_mode() {
  is_in_multi_window_mode_ = false;
  clear_has_is_in_multi_window_mode();
}
inline bool LauncherEvent::is_in_multi_window_mode() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.is_in_multi_window_mode)
  return is_in_multi_window_mode_;
}
inline void LauncherEvent::set_is_in_multi_window_mode(bool value) {
  set_has_is_in_multi_window_mode();
  is_in_multi_window_mode_ = value;
  // @@protoc_insertion_point(field_set:userevent.LauncherEvent.is_in_multi_window_mode)
}

// optional bool is_in_landscape_mode = 8;
inline bool LauncherEvent::has_is_in_landscape_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LauncherEvent::set_has_is_in_landscape_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LauncherEvent::clear_has_is_in_landscape_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LauncherEvent::clear_is_in_landscape_mode() {
  is_in_landscape_mode_ = false;
  clear_has_is_in_landscape_mode();
}
inline bool LauncherEvent::is_in_landscape_mode() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.is_in_landscape_mode)
  return is_in_landscape_mode_;
}
inline void LauncherEvent::set_is_in_landscape_mode(bool value) {
  set_has_is_in_landscape_mode();
  is_in_landscape_mode_ = value;
  // @@protoc_insertion_point(field_set:userevent.LauncherEvent.is_in_landscape_mode)
}

// optional .userevent.LauncherEventExtension extension = 9;
inline bool LauncherEvent::has_extension() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LauncherEvent::set_has_extension() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LauncherEvent::clear_has_extension() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LauncherEvent::clear_extension() {
  if (extension_ != NULL) extension_->::userevent::LauncherEventExtension::Clear();
  clear_has_extension();
}
inline const ::userevent::LauncherEventExtension& LauncherEvent::extension() const {
  // @@protoc_insertion_point(field_get:userevent.LauncherEvent.extension)
  return extension_ != NULL ? *extension_
                         : *::userevent::LauncherEventExtension::internal_default_instance();
}
inline ::userevent::LauncherEventExtension* LauncherEvent::mutable_extension() {
  set_has_extension();
  if (extension_ == NULL) {
    extension_ = new ::userevent::LauncherEventExtension;
  }
  // @@protoc_insertion_point(field_mutable:userevent.LauncherEvent.extension)
  return extension_;
}
inline ::userevent::LauncherEventExtension* LauncherEvent::release_extension() {
  // @@protoc_insertion_point(field_release:userevent.LauncherEvent.extension)
  clear_has_extension();
  ::userevent::LauncherEventExtension* temp = extension_;
  extension_ = NULL;
  return temp;
}
inline void LauncherEvent::set_allocated_extension(::userevent::LauncherEventExtension* extension) {
  delete extension_;
  extension_ = extension;
  if (extension) {
    set_has_extension();
  } else {
    clear_has_extension();
  }
  // @@protoc_insertion_point(field_set_allocated:userevent.LauncherEvent.extension)
}

inline const LauncherEvent* LauncherEvent::internal_default_instance() {
  return &LauncherEvent_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace userevent

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::userevent::Target_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::Target_Type>() {
  return ::userevent::Target_Type_descriptor();
}
template <> struct is_proto_enum< ::userevent::Action_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::Action_Type>() {
  return ::userevent::Action_Type_descriptor();
}
template <> struct is_proto_enum< ::userevent::Action_Touch> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::Action_Touch>() {
  return ::userevent::Action_Touch_descriptor();
}
template <> struct is_proto_enum< ::userevent::Action_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::Action_Direction>() {
  return ::userevent::Action_Direction_descriptor();
}
template <> struct is_proto_enum< ::userevent::Action_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::Action_Command>() {
  return ::userevent::Action_Command_descriptor();
}
template <> struct is_proto_enum< ::userevent::ItemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::ItemType>() {
  return ::userevent::ItemType_descriptor();
}
template <> struct is_proto_enum< ::userevent::ContainerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::ContainerType>() {
  return ::userevent::ContainerType_descriptor();
}
template <> struct is_proto_enum< ::userevent::ControlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::ControlType>() {
  return ::userevent::ControlType_descriptor();
}
template <> struct is_proto_enum< ::userevent::TipType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::userevent::TipType>() {
  return ::userevent::TipType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_launcher_5flog_2eproto__INCLUDED
